<!DOCTYPE html>
<html lang="ja" xmlns:th="http://www.thymeleaf.org" >
<head>
	<meta charset="UTF-8">
	<title>たつや学長の誰でも完璧メール</title>
	<script th:src="@{/jquery/jquery-3.5.1.min.js}"></script>
    <!-- Bootstrap CSS-->
	<link rel="stylesheet" th:href="@{/bootstrap/css/bootstrap.min.css}">
	<!-- JSMindMap CSS -->
	<link rel="stylesheet" href="/jsmind/style/jsmind.css" th:href="@{/css/jsmind.css}" />
	<!-- <link rel="text/javascript" th:href="@{/bootstrap/js/bootstrap.min.js}"> -->
	<script th:src="@{/bootstrap/js/bootstrap.min.js}"></script>
	<!-- <link rel="text/javascript" th:href="@{/jquery/jquery-3.5.1.min.js}"> -->
	<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
	<script src="http://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>
<body>
	<div id="jsmind_container" style="width:100%;height:900px;"></div>
	
	<script th:src="@{/javascript/mindmap/jsmind.js}"></script>
	<script type="text/javascript" th:inline="javascript">
		/*<![CDATA[*/
			/**
			 * ロジカルツリー図の作成を行う.
			 * 
			 * @param logicTree ロジックツリー情報
			 */
			const loadJsmind = (logicTree) => {
				/** 課題部分の作成を行う */
				const task = createTask(logicTree)
				/** 子要素(第一,二,三階層)の作成を行う(現状第一のみ) */
				const children = createFirstHierarchy(logicTree.firstHierarchyList);
				/** マインドマップの作成 */
			    const mind = {
			        "meta":{
			            "name":"jsMind remote"
			        },
			        "format":"node_tree",
			        "data":{"id":"root","topic":`課題<br>${task}`, "children": children
			        //ロジックマップ作成後消去予定

			        }
			    };
				console.log(mind)
			    const options = {
			        container:'jsmind_container',
			        editable:true,
			        theme:'primary'
			    }
			    
			    const jm = jsMind.show(options,mind);
			    jm.add_node("sub2","sub23", "new node", {"background-color":"red"});
			    jm.set_node_color('sub21', 'green', '#ccc');
			}
			
			/**
			 * 文章の改行を行う.
			 * 
			 * @param sentense 文章
			 * @return 14字で改行された文章
			 */
			const handleSentense = (sentense) => {
				let sentenseList = [];
				for(let i = 0; i <= sentense.length; i++){
					let letter = sentense.slice(i, i+1)
					if(i != 0 && i % 14 === 0){
						letter += `<br>`
					}
					sentenseList.push(letter)
				}
				return sentenseList.join('')
			}
			
			/**
			 * 第三階層リストの作成を行う.
			 * 
			 * @param thirdHierarchyList 第三階層リスト
			 * @return 第三階層リスト
			 */
			const createThirdHierarchy = (thirdHierarchyList) => {
				thirdHierarchyList = thirdHierarchyList.filter((thirdHierarchy) => {
					return !!thirdHierarchy.explanation
				})
				const thirdHierarchy = thirdHierarchyList.map((thirdHierarchy) => {
					return {"id": `${thirdHierarchy.explanation}`,
							  "topic":`${handleSentense(thirdHierarchy.explanation)}`, 
							  "direction": "right"
					}
				})
				return thirdHierarchy
			}
			
			/**
			 * 第二階層リストの作成を行う.
			 * 
			 * @param secondHierarchyList 第二階層リスト
			 * @return 第二階層リスト
			 */
			const createSecondHierarchy = (secondHierarchyList) => {
				secondHierarchyList = secondHierarchyList.filter((secondHierarchy) => {
					return !!secondHierarchy.explanation
				})
				const secondHierarchy = secondHierarchyList.map((secondHierarchy) => {
						return {"id": `${secondHierarchy.explanation}`,
								  "topic":`${handleSentense(secondHierarchy.explanation)}`, 
								  "direction": "right",
								  "children": createThirdHierarchy(secondHierarchy.thirdHierarchyList)
						}						
				})
				return secondHierarchy
			}
			
			/**
			 * ロジックツリーの子要素を追加する.
			 *  * 
			 * @param firstHierarchyList 第一階層情報リスト
			 * @return 第一階層情報
			 */
			const createFirstHierarchy = (firstHierarchyList) => {
				/** 第一階層のマインドマップを作成する */
				const firstHierarchy = firstHierarchyList.map((firstHierarchy) => {
					return {"id": `${firstHierarchy.word}`, 
							  "topic": `${firstHierarchy.word}<br>${handleSentense(firstHierarchy.anotherWord)}`, 
							  "direction": "right",
							  "children": createSecondHierarchy(firstHierarchy.secondHierarchyList)
					}
				});
				return firstHierarchy
			}
			
			/**
			 * ロジックツリー課題部分の作成を行う.
			 * 
			 * @param partnerWants 求めるもの
			 * @param currentState 現状
			 * @param descriptionType 説明文の種類(1=原因,2=方法)
			 * @return 課題情報
			 */
			const createTask = ({ partnerWants, currentState, descriptionType }) => {
				const type = descriptionType === '1' ? `この課題の原因にはどのようなものが考えられるか？` : `この課題を解決するにはどのような方法が考えられるか？` ;
				const inputTaskSentense = `${partnerWants}に対して${currentState}のギャップが課題です。${type}`;
				const taskSentense = handleSentense(inputTaskSentense)
				return taskSentense
			}
			
			/** 入力した第一階層リストの取得 */
			let firstHierarchyList = /*[[ ${logicTree.firstHierarchyList} ]]*/
			
			/** 言い換えがnull以外でない項目のみ表示を行う */
		    firstHierarchyList = firstHierarchyList.filter((firstHierarchy) => {
				return firstHierarchy.anotherWord !== null
			})
			
			firstHierarchyList.forEach((firstHierarchy) => {
				firstHierarchy.secondHierarchyList.filter((secondHierarchy) => {
					console.log(!!secondHierarchy.explanation)
					return !!secondHierarchy.explanation
				})
			})
			console.log(firstHierarchyList)
			
			/** ロジカルツリーの中身作成 */
			const logicTree = {
				partnerWants : /*[[ 「 + ${logicTree.partnerWants} + 」 ]]*/,
				currentState : /*[[ 「 + ${logicTree.currentState} + 」 ]]*/,
				descriptionType : /*[[ ${logicTree.descriptionType} ]]*/,
				firstHierarchyList
			}	
			loadJsmind(logicTree)	
		/*]]>*/
	</script>
</body>
</html>